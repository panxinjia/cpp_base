#include <iostream>

using namespace std;

/**
 * 继承与派生 (扩展,复用的不同角度)
 *  OCP 开闭原则, LSP 里式替换原则, 单一职责原则 
 * > 不影响原来的类, 不改变原来类的代码, 实现对功能的扩展, 原有类基础上快速增加新功能
 * > 继承方式
 *  - 超过90%都是public继承, 特殊情况(设计模式)会用到private继承
 * > 父子关系
 *  - 构造, 拷贝构造,析构是不继承的
 *  - 多继承的相同成员访问
 *  - 派生类对象, 可以当做基类的对象使用
 *  - 父类对象子类对象相互赋值, 指针相互指向
 *  - 构造和析构的顺序  初始化列表传递父构造函数 
 * > 菱形继承
 *  - 菱形继承造成的冗余
 *  - 直接父类访问 
 *  - 解决冗余 -> 虚继承 ( 存在一个虚指针, 指向继承了什么, 发生菱形继承的时候就起到作用了 )
 * 
 * 
 * =delete =default =0
 * 
 * polymorphism 多态
 *  - 多态 联编(绑定)  动态绑定, 静态绑定
 *      动态绑定
 *      1. class, 虚函数
 *      2. 继承关系
 *      3. 基类指针/引用 指向或引用子类对象, 函数调用的时候通过 vtable 做到动态绑定
 *          vtable 是不会被继承的, 每个class的虚函数表都是指向自己应当的部分
 *  - 纯虚函数 ( 抽象类, 接口 ), 函数遮蔽, 虚析构和内存释放问题
 *      - 声明了纯虚函数的类就是抽象的类
 *      - 全部都是纯虚函数的类, 类比为接口
 *  - final 
 *      阻止继承, 阻止覆盖
 *  - override
 *      验证重写的关键字
 *  - 实际开发中使用多态
 * 
 */
int main(int argc, const char *argv[])
{

    cout << "main.cpp" << endl;
    return 0;
}